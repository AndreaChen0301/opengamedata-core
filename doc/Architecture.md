The general structure and data flow for the exporter/extractor is as follows:  
1. At the highest level, we have main.py. This is the file you run to set off the whole process. The code in main loads the program settings, connects to the database, and constructs a "request" for the DataToCSV.py module, which holds the core logic for the process. Currently, the request is hardcoded in main.py, but in the future should support command line arguments.
2. The next level is DataToCSV.py. This is where we do the high-level processing. Given the database connection, settings, and request, DataToCSV will load additional data for the game specified by the request, retrieve data for that game, and export both raw and processed csv files.
The "additional data" includes:
   - a GameTable, which has information on the database table with game data, and "what" data is available.
   - a Schema, which has information on the structure of the stored game data itself.
   
   DataToCSV makes use of two "manager" classes (one for raw data, one for processed), which each provide functions for processing a single row, and writing out accumulated data to a file. This means DataToCSV is only directly responsible for checking the number of sessions available for the game, and retrieving the rows for each session. It then passes each row to the RawManager and the ProcManager, and periodically uses the managers to write the data to file.
   Finally, DataToCSV maintains a JSON file with data on all exported csv files.
3. a. RawManager.py is responsible for the details of processing each database row. This basically amounts to splitting columns storing JSON data into multiple smaller columns, and ensuring any columns which may have commas in them (strings, sub-objects) are wrapped in quotes. Each time a row is processed, the corresponding csv line is added to a list, which may be written to file at any time. Note, RawManager has a ClearLines function, which should be (and presently is) called after using the WriteRawCSVLines function to avoid writing duplicate lines.
3. b. ProcManager.py has similar responsibilities to RawManager, however the details of processing a row are somewhat more complicated. Because a processed csv has features calculated from data, rather than simply being a lightly processed version of the raw data itself, there is a lot of variation between games. Thus, ProcManager further defers details to Extractor classes, each instance of which can maintain feature data for one session. ProcManager simply makes use of the `extractFromRow` function provided by each Extractor, as well as an Extractor function for writing data to a given file. ProcManager also has a function for calculating aggregate features of all sessions, which should generally be used before writing data to csv.
4. The Extractor classes are based on Extractor.py, which is an abstract class defining a few functions that operate across all subclasses, and a few abstract functions which should be implemented by each subclass.
The abstract functions are `extractFromRow` and `calculateAggregateFeatures`, which are the two points that vary from game to game. Each implementation of `extractFromRow` should handle all possible event types (each row represents one event) for the given game. These events are documented in the game's Schema file.
An extractor stores feature data in a private class, which provides functions for accessing and modifying features by name (useful for aggregate features) or index (e.g. index may be level or question number).