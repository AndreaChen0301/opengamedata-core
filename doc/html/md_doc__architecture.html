<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>feature_extraction_to_csv: Architecture</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">feature_extraction_to_csv
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Tool to extract features from game database, and export to csv.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Architecture </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>This document gives a general overview of the various pieces of code in the opengamedata project.</b></p>
<h4>Basic Categories</h4>
<p>The project code has three primary parts:</p><ol type="1">
<li><b>Extraction</b> code to extract features from raw game log data, retrieved from a database.</li>
<li><b>Export</b> code to perform feature extraction at scale, and export the data to files for distribution/archival.</li>
<li><b>Evaluation</b> code to run features of a game session through models (generated from past game data), and output model-based predictions.</li>
</ol>
<h4>Location(s) of code by category</h4>
<p>The extraction code is primarily located in feature_extractors folder, and makes use of data in the schemas folder. Export code mostly lives in the managers folder, and is invoked from main.py. Evaluation code is, at the time of writing, wrapped up in RTServer.py, which was part of a dashboard prototype. In future development, these should be separated somewhat. Evaluation and Export code make heavy use of the Extraction code.</p>
<h4>Code hierarchy and structure</h4>
<p>The general structure and data flow for the <b>exporter</b> code is as follows:</p>
<ol type="1">
<li>At the highest level, we have main.py. This is the file you run to set off the whole process. The code in main loads the program settings and constructs a "request" for the <a class="el" href="class_export_manager.html" title="A class to export features and raw data, given a Request object.">ExportManager</a> module, which holds the core logic for the process. The details of the request are determined by the command-line args given to main.</li>
<li><p class="startli">The next level is ExportManager.py. This is where we do the high-level export processing. Given the export request, <a class="el" href="class_export_manager.html" title="A class to export features and raw data, given a Request object.">ExportManager</a> will load additional data for the game specified by the request, retrieve data for that game from the database, and export both raw and processed csv files. The "additional data" includes:</p><ul>
<li>a <a class="el" href="class_game_table.html" title="Dumb struct to hold useful info about the structure of database data for a particular game.">GameTable</a>, which has information on the database table with game data, and "what" data is available.</li>
<li>a Schema, which has information on the structure of the stored game data itself. Specifically, this deals with data encoded within a string in a specific database column.</li>
</ul>
<p class="startli"><a class="el" href="class_export_manager.html" title="A class to export features and raw data, given a Request object.">ExportManager</a> makes use of two further "manager" classes (one for raw data, one for processed), which each provide functions for processing a single row, and writing out accumulated data to a file. This means <a class="el" href="class_export_manager.html" title="A class to export features and raw data, given a Request object.">ExportManager</a> is only directly responsible for checking the number of sessions available for the game, and retrieving the rows for each session. It then passes each row to the <a class="el" href="class_raw_manager.html" title="Class to manage data for a raw csv file.">RawManager</a> and the <a class="el" href="class_proc_manager.html" title="Class to extract and manage features for a processed csv file.">ProcManager</a>, and periodically uses the managers to write the data to file. Finally, <a class="el" href="class_export_manager.html" title="A class to export features and raw data, given a Request object.">ExportManager</a> maintains a JSON file with data on all exported csv files.</p>
</li>
<li>a. RawManager.py is responsible for the details of processing each database row. This basically amounts to splitting any columns that contain JSON data into multiple smaller columns, and ensuring any columns which may have commas in them (strings, sub-objects) are wrapped in quotes. Each time a row is processed, the corresponding csv line is added to a list, which may be written to file at any time. Note, <a class="el" href="class_raw_manager.html" title="Class to manage data for a raw csv file.">RawManager</a> has a ClearLines function, which should be (and presently is) called after using the WriteRawCSVLines function to avoid writing duplicate lines.</li>
</ol>
<ol type="1">
<li>b. ProcManager.py has similar responsibilities to <a class="el" href="class_raw_manager.html" title="Class to manage data for a raw csv file.">RawManager</a>, however the details of processing a row are somewhat more complicated. Because a processed csv has features calculated from data, rather than simply being a lightly processed version of the raw data itself, there is a lot of variation between games. Thus, <a class="el" href="class_proc_manager.html" title="Class to extract and manage features for a processed csv file.">ProcManager</a> further defers details to Extractor classes, each instance of which can maintain feature data for one session. <a class="el" href="class_proc_manager.html" title="Class to extract and manage features for a processed csv file.">ProcManager</a> simply makes use of the <code>extractFromRow</code> function provided by each Extractor, as well as an Extractor function for writing data to a given file. <a class="el" href="class_proc_manager.html" title="Class to extract and manage features for a processed csv file.">ProcManager</a> also has a function for calculating aggregate features of all sessions, which should generally be used before writing data to csv.</li>
<li>The Extractor classes are based on Extractor.py, which is an abstract class defining a few functions that operate across all subclasses, and a few abstract functions which should be implemented by each subclass. The abstract functions are <code>extractFromRow</code> and <code>calculateAggregateFeatures</code>, which are the two points that vary from game to game. Each implementation of <code>extractFromRow</code> should handle all possible event types (each row represents one event) for the given game. These events are documented in the game's Schema file. An extractor stores feature data in a private class, which provides functions for accessing and modifying features by name (useful for aggregate features) or index (e.g. index may be level or question number).</li>
</ol>
<p>The <b>evaluator</b> code is somewhat wrapped up in the code for a real-time dashboard, at present. Future development should result in a cleaner separation of features. The list below is thus less of a hierarchy, more of a description of where each piece (and examples of use) can be found in the code.</p><ol type="1">
<li>RTServer.py contains the function of interest for evaluating models, called EvaluateLogRegModel (at present, we are only using logistic regression models; this should expand in the future). This function accepts a "model" and feature data for a given play session.</li>
<li>Models are stored as json files, which at the least must map the "code" name of a model to a corresponding dictionary. The model dictionary maps input parameter names to coefficient values, and at the least will map "display name" to a nicely formatted string used to display the name of the model in an end-user application. It is this dictionary that gets passed to EvaluateLogRegModel.</li>
<li>The clearest example for using models is in getPredictionsBySessID within RTServer.py. This uses a model file that adds an extra level to the JSON, separating models by the game level for which they are intended.</li>
</ol>
<p>In the future, the intent is to have a separate module for model evaluation, which would allow us to do things like run models on test data, and export results for evaluation of model effectiveness, or creation of model benchmarks. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
