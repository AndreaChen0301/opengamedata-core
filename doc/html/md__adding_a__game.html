<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>feature_extraction_to_csv: Adding a new game data exporter/extractor:</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">feature_extraction_to_csv
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Tool to extract features from game database, and export to csv.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Adding a new game data exporter/extractor: </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>First, a bit of terminology:</p><ul>
<li>feature: Some bit of data considered to be useful for analysis of game play. Usually calculated from game event data.</li>
<li>per-level feature: A feature that records data about what a player did over the course of a level in the game.</li>
<li>per-custom-count feature: A feature that records data about some <em>thing</em> that may have multiple instances over a gameplay session. A common example would be question-answer prompts.</li>
<li>aggregate feature: A feature which records data across an entire gameplay session (as opposed to an individual level, for example).</li>
<li>raw csv: A csv file containing raw game event data. More-or-less a database dump, but with JSON objects split across columns.</li>
<li>processed csv: A csv file primarily containing feature data. This typically includes a great many per-level features (i.e. one instance of each feature per game level), a few per-custom-count features, and a moderate number of aggregate features.</li>
</ul>
<p>In order to add a new game to the feature extraction tool, complete the following steps:</p>
<ol type="1">
<li>First, we must define some things about the data we are extracting. We do this in a JSON file, under the <b>schemas/JSON</b> folder. By convention, the name of the JSON file should be the same as the game ID used in the database.</li>
</ol>
<p>e.g. For the "Wave" game, the database uses an app_id of <code>WAVES</code>, so we name the JSON schema file as <b>WAVES.json</b> A JSON schema file has three elements:</p><ul>
<li><code>db_columns</code>: This element should be a dictionary mapping the names of each column in the database table to a string describing the column.</li>
<li><code>events</code>: This element should be a dictionary mapping names of event types to sub-dictionaries defining the data in the events.<ul>
<li>These sub-dictionaries are similar to the db_columns dictionary. They map each property name for a given event type to the type of that property.</li>
</ul>
</li>
<li><code>features</code>: This element should in turn contain three elements:<ul>
<li><code>perlevel</code>: This sub-element should be a dictionary mapping the names of per-level features to descriptions of how the features are calculated.</li>
<li><p class="startli"><code>per_custom_count</code>: This sub-element should be a dictionary mapping the names of features which are repeated for some specific number of times to a subdictionary. This, again, has three elements:</p><ul>
<li><code>count</code>: The number of times the feature is repeated</li>
<li><code>prefix</code>: The prefix to use to distinguish repeats of the feature in the output file</li>
<li><code>desc</code>: A description of how the feature is calculated</li>
</ul>
<p class="startli">Note, if you know a priori the number of levels in your game, you may enter all your <code>perlevel</code> features as <code>per_custom_count</code> features. The only difference between the two is that <code>perlevel</code> features have a hard-coded prefix ("lvl") and the number of levels is inferred from the max level in the database.</p>
</li>
</ul>
</li>
</ul>
<p><code>aggregate</code>: This sub-element should be a dictionary mapping the names of features aggregated over a whole session to descriptions of how the features are calculated. <code>db_columns</code> is used to ensure the raw csv file metadata contains descriptions of each database column. <code>events</code> are used to get names for the members of each kind of event so we can extract features (and create columns in the raw csv). <code>features</code> are used to ensure the processed csv file metadata contains descriptions of each feature, and to help document the features for whoever writes the actual feature extraction code. Below is a sample of JSON schema formatting: </p><div class="fragment"><div class="line">{</div><div class="line">    &quot;db_columns&quot;: {</div><div class="line">        &quot;id&quot;:&quot;Unique identifier for a row&quot;,</div><div class="line">    },</div><div class="line"></div><div class="line">    &quot;events&quot;: {</div><div class="line">        &quot;ARROW_MOVE_RELEASE&quot;: {</div><div class="line">            &quot;event_custom&quot;:&quot;string&quot;,</div><div class="line">            &quot;begin_val&quot;:&quot;float&quot;,</div><div class="line">            &quot;end_val&quot;:&quot;float&quot;</div><div class="line">        }</div><div class="line">    },</div><div class="line"></div><div class="line">    &quot;features&quot;: {</div><div class="line">        &quot;perlevel&quot;: {</div><div class="line">            &quot;totalSliderMoves&quot;:&quot;slider moves across a given level&quot;,</div><div class="line">        },</div><div class="line">        &quot;per_custom_count&quot;: {</div><div class="line">            &quot;questionAnswered&quot; : {&quot;count&quot; : 4, &quot;prefix&quot;: &quot;QA&quot;, &quot;desc&quot; : &quot;The answer the user gave to a given question (or -1 if unanswered)&quot;},</div><div class="line">        },</div><div class="line">        &quot;aggregate&quot;: {</div><div class="line">            &quot;avgSliderMoves&quot; : &quot;totalSliderMoves averaged over all levels&quot;,</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><ol type="1">
<li><p class="startli">Next, we need to create the feature extractor. This will be a Python class inheriting from the <code>Extractor</code> base class. By convention, the class should use the database app_id as a prefix for the class name, but use CamelCase even if the app_id is not formatted as such. e.g. For the "Wave" game, we would name the extractor <code>WaveExtractor</code> (as opposed to <code>app_id + "Extractor</code> =&gt; <code>WAVEExtractor</code>). The <code>Extractor</code> subclass <em>must</em> implement the following functions:</p><ul>
<li><code>__init__(self, session_id, game_table, game_schema)</code>: At minimum, this function should call the super constructor. <code>session_id</code> has the id of the session we are extracting data from, <code>game_table</code> contains information about the database table, and <code>game_schema</code> contains the data from the schema we defined in step 1. The super constructor initializes all features to have values of 0. If a different default value is preferred for any features, it would be a good idea to set those values here, after calling the super constructor.</li>
<li><code>extractFromRow(self, row_with_complex_parsed, game_table)</code>: This function is responsible for extracting feature data from a single database entry. The <code>row_with_complex_parsed</code> should a row returned from the database, but with the item at <code>event_data_complex</code> already parsed into a Python dictionary from JSON. If step 1 was completed correctly, the <code>event_data_complex</code> ought to match one of the <code>event</code>s from the JSON schema. The <code>game_table</code> holds information about the layout of the database table, as usual. It can be used to get items from the row at specific columns. This function should contain code to handle extraction from each <code>event</code> type. By convention, the actual extraction code should be split into separate private functions for each <code>event</code> type, so that we can get a cleanly-formatted <code>extractFromRow</code> function, as below: ```python event_type = event_data_complex_parsed["event_custom"] if event_type == "BEGIN": self._extractFromBegin(level, event_client_time) elif event_type == "COMPLETE": self._extractFromComplete(level, event_client_time) elif event_type == "SUCCEED": <h1>etc.</h1>
</li>
</ul>
<p class="startli">```</p>
<p class="startli">Each private function should then update feature values as needed: ```python def _extractFromComplete(self, level, event_client_time): self.end_times[level] = event_client_time self.features["completed"][level]["val"] = 1 ``<code> Also note that in general, we use</code>row_with_complex_parsed["event_data_complex]["event_custom"]` to distinguish event types. Even if the original database entry did not have `event_custom` as a part of the JSON, the `ProcManager` class will insert the value of the `event` database column as `event_custom` in the `row_with_complex_parsed["event_data_complex]<code>object, so there is at least _some_ way to tell what type of event is being processed. -</code>calculateAggregateFeatures(self)`: This function should use the values in its per-level and per-custom-count features to calculate the aggregate (across whole session) features. The code for calculating individual aggregate features may be broken into separate private functions if desired, although in practice most aggregate features can be calculated with just a couple lines of code apiece, so this is not usually necessary. This function will generally be called just once during each extractor's lifetime, after all rows corresponding to that session have been processed.</p>
</li>
<li>Next, we need to ensure DataToCSV knows what the possible games are. In the section of code (presently around line 70) dealing with loading of the schema file, we need to add a case to the if-elif-else block. It should check if the request object has a game_id matching our new game, and if so, we must call the Schema constructor with the name of the schema file from step 1, and we must set <code>game_extractor</code> to the Extractor class we created for the game. For example: <div class="fragment"><div class="line">if request.game_id == &quot;WAVES&quot;:</div><div class="line">    game_schema = Schema(schema_name=&quot;WAVES.json&quot;)</div><div class="line">    game_extractor = WaveExtractor</div></div><!-- fragment --></li>
<li>Once those three steps are completed, the only thing left is to call DataToCSV with a request using the new game's app_id. This is usually done from main.py. </li>
</ol>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
